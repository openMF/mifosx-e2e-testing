// Copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)

package org.xbill.DNS;

import org.xbill.DNS.utils.base16;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

// TODO: Auto-generated Javadoc
/**
 * Options - describes Extended DNS (EDNS) properties of a Message. No specific
 * options are defined other than those specified in the header. An OPT should
 * be generated by Resolver.
 * 
 * EDNS is a method to extend the DNS protocol while providing backwards
 * compatibility and not significantly changing the protocol. This
 * implementation of EDNS is mostly complete at level 0.
 * 
 * @see Message
 * @see Resolver
 * 
 * @author Brian Wellington
 */

public class OPTRecord extends Record {

	/** The Constant serialVersionUID. */
	private static final long serialVersionUID = -6254521894809367938L;

	/**
	 * The Class Option.
	 */
	public static class Option {

		/** The code. */
		public final int code;

		/** The data. */
		public final byte[] data;

		/**
		 * Creates an option with the given option code and data.
		 * 
		 * @param code
		 *            the code
		 * @param data
		 *            the data
		 */
		public Option(int code, byte[] data) {
			this.code = checkU8("option code", code);
			this.data = data;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#toString()
		 */
		public String toString() {
			return "{" + code + " <" + base16.toString(data) + ">}";
		}
	}

	/** The options. */
	private List options;

	/**
	 * Instantiates a new oPT record.
	 */
	OPTRecord() {
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.xbill.DNS.Record#getObject()
	 */
	Record getObject() {
		return new OPTRecord();
	}

	/**
	 * Creates an OPT Record. This is normally called by SimpleResolver, but can
	 * also be called by a server.
	 * 
	 * @param payloadSize
	 *            The size of a packet that can be reassembled on the sending
	 *            host.
	 * @param xrcode
	 *            The value of the extended rcode field. This is the upper 16
	 *            bits of the full rcode.
	 * @param version
	 *            The EDNS version that this DNS implementation supports. This
	 *            should be 0 for dnsjava.
	 * @param flags
	 *            Additional message flags.
	 * @param options
	 *            The list of options that comprise the data field. There are
	 *            currently no defined options.
	 * @see ExtendedFlags
	 */
	public OPTRecord(int payloadSize, int xrcode, int version, int flags,
			List options) {
		super(Name.root, Type.OPT, payloadSize, 0);
		checkU16("payloadSize", payloadSize);
		checkU8("xrcode", xrcode);
		checkU8("version", version);
		checkU16("flags", flags);
		ttl = ((long) xrcode << 24) + ((long) version << 16) + flags;
		if (options != null) {
			this.options = new ArrayList(options);
		}
	}

	/**
	 * Creates an OPT Record with no data. This is normally called by
	 * SimpleResolver, but can also be called by a server.
	 * 
	 * @param payloadSize
	 *            The size of a packet that can be reassembled on the sending
	 *            host.
	 * @param xrcode
	 *            The value of the extended rcode field. This is the upper 16
	 *            bits of the full rcode.
	 * @param version
	 *            The EDNS version that this DNS implementation supports. This
	 *            should be 0 for dnsjava.
	 * @param flags
	 *            Additional message flags.
	 * @see ExtendedFlags
	 */
	public OPTRecord(int payloadSize, int xrcode, int version, int flags) {
		this(payloadSize, xrcode, version, flags, null);
	}

	/**
	 * Creates an OPT Record with no data. This is normally called by
	 * SimpleResolver, but can also be called by a server.
	 * 
	 * @param payloadSize
	 *            the payload size
	 * @param xrcode
	 *            the xrcode
	 * @param version
	 *            the version
	 */
	public OPTRecord(int payloadSize, int xrcode, int version) {
		this(payloadSize, xrcode, version, 0, null);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.xbill.DNS.Record#rrFromWire(org.xbill.DNS.DNSInput)
	 */
	void rrFromWire(DNSInput in) throws IOException {
		if (in.remaining() > 0)
			options = new ArrayList();
		while (in.remaining() > 0) {
			int code = in.readU16();
			int len = in.readU16();
			byte[] data = in.readByteArray(len);
			options.add(new Option(code, data));
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.xbill.DNS.Record#rdataFromString(org.xbill.DNS.Tokenizer,
	 * org.xbill.DNS.Name)
	 */
	void rdataFromString(Tokenizer st, Name origin) throws IOException {
		throw st.exception("no text format defined for OPT");
	}

	/**
	 * Converts rdata to a String.
	 * 
	 * @return the string
	 */
	String rrToString() {
		StringBuffer sb = new StringBuffer();
		if (options != null) {
			sb.append(options);
			sb.append(" ");
		}
		sb.append(" ; payload ");
		sb.append(getPayloadSize());
		sb.append(", xrcode ");
		sb.append(getExtendedRcode());
		sb.append(", version ");
		sb.append(getVersion());
		sb.append(", flags ");
		sb.append(getFlags());
		return sb.toString();
	}

	/**
	 * Returns the maximum allowed payload size.
	 * 
	 * @return the payload size
	 */
	public int getPayloadSize() {
		return dclass;
	}

	/**
	 * Returns the extended Rcode.
	 * 
	 * @return the extended rcode
	 * @see Rcode
	 */
	public int getExtendedRcode() {
		return (int) (ttl >>> 24);
	}

	/**
	 * Returns the highest supported EDNS version.
	 * 
	 * @return the version
	 */
	public int getVersion() {
		return (int) ((ttl >>> 16) & 0xFF);
	}

	/**
	 * Returns the EDNS flags.
	 * 
	 * @return the flags
	 */
	public int getFlags() {
		return (int) (ttl & 0xFFFF);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.xbill.DNS.Record#rrToWire(org.xbill.DNS.DNSOutput,
	 * org.xbill.DNS.Compression, boolean)
	 */
	void rrToWire(DNSOutput out, Compression c, boolean canonical) {
		if (options == null)
			return;
		Iterator it = options.iterator();
		while (it.hasNext()) {
			Option opt = (Option) it.next();
			out.writeU16(opt.code);
			out.writeU16(opt.data.length);
			out.writeByteArray(opt.data);
		}
	}

	/**
	 * Gets all options in the OPTRecord. This returns a list of Options.
	 * 
	 * @return the options
	 */
	public List getOptions() {
		if (options == null)
			return Collections.EMPTY_LIST;
		return Collections.unmodifiableList(options);
	}

	/**
	 * Gets all options in the OPTRecord with a specific code. This returns a
	 * list of byte arrays.
	 * 
	 * @param code
	 *            the code
	 * @return the options
	 */
	public List getOptions(int code) {
		if (options == null)
			return Collections.EMPTY_LIST;
		List list = null;
		for (Iterator it = options.iterator(); it.hasNext();) {
			Option opt = (Option) it.next();
			if (opt.code == code) {
				if (list == null)
					list = new ArrayList();
				list.add(opt.data);
			}
		}
		if (list == null)
			return Collections.EMPTY_LIST;
		return list;
	}

}
